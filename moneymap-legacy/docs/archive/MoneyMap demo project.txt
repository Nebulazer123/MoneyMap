MoneyMap demo project
Design document and roadmap

---

## 1. Project overview

MoneyMap is a personal finance dashboard that lives completely in the browser for now.
Phase 1 is a pure demo. It runs only on synthetic data, accepts no real uploads, and never connects to a bank.

The point of the demo is not just to show four numbers at the top of a screen. The point is to walk a stressed, disorganized user through a realistic statement, clean it up, detect transfers and subscriptions correctly, and then present the results in a way that is helpful without being panic inducing.

Future phases should be able to take an uploaded CSV or similar statement file and run the exact same analysis pipeline you build for the demo. The fake data generator should behave like a stand in for a messy real statement.

Target audience

* Normal people who do not enjoy money management, feel behind, and want a clear picture of where their money is going
* Secondary audience is employers or coaches who may view the demo to understand the concept

High level constraints

* Privacy first
  Synthetic only in Phase 1, and local parsing only in later phases
  No raw transaction data is sent to a server or to third party APIs unless the user makes a very explicit choice in some later phase
* Tech stack is beginner friendly and centered around the modern React app router

---

## 2. Technical stack and environment

Core technologies

* Next.js app router (current version already in the project)
* React with TypeScript
* Tailwind CSS for styling
* Node and npm for tooling
* Local development in Visual Studio Code
* Planned hosting on Firebase for public demo

Layout structure

* Global layout in `src/app/layout.tsx`
* Navigation bar component in `src/components/NavBar.tsx` (client component, uses `usePathname`)
* Page routes in the `app` folder
  `src/app/page.tsx` for Home
  `src/app/demo/page.tsx` for the demo dashboard
  `src/app/about/page.tsx` for the About screen

Data and helpers

* `src/lib/fakeData.ts` holds the synthetic transaction list and all helper functions for analytics and guidance
* All financial math lives here so the UI is as dumb as possible

---

## 3. Product pillars

1. Privacy first
   No real bank links in the demo. Future real parsing is designed to run entirely in the browser first.

2. Guided demo, not just a static screenshot
   The home page should invite the user into a process:

   * Generate a fake, messy statement with random merchants and amounts
   * Let them inspect it
   * Then let them press an Analyze button that runs the pipeline and shows the dashboard

3. Transfer aware math
   Internal transfers between the user’s own accounts should not inflate income or spending totals.
   External transfers, card cash outs, and cash ins should be treated like real inflows or real spending.

4. Helpful, calm feedback
   The Review tab explains what is happening in plain language.
   Example: “Rent is about 32 percent of this month’s income. A common guideline is around 30 percent. You are about 140 dollars over that guideline.”

5. No fake shortcuts in the analysis
   The system must calculate results from the transactions themselves, not from hard coded totals.
   When this later reads a real CSV, the code should already be doing the correct math.

---

## 4. Routes and screens

### 4.1 App layout and navigation

Global layout

* Dark theme with subtle borders and rounded cards
* Top bar shows the MoneyMap logo and three nav links: Home, Demo, About
* The current route link is visually highlighted (brighter text and underline)

Responsive behavior

* Reduced padding on small screens so content is not squeezed at the edges
* Navigation collapses gracefully without wrapping awkwardly
* Font sizes scale down on mobile, especially in tables and summary cards

### 4.2 Home page (`/`)

Purpose

* Light copy that explains MoneyMap as a “fake spending dashboard” for now
* Very clear text that this is Phase 1, synthetic data only, no real uploads or bank connections

Future upgrade for Phase 2

* Add a large call to action button
  Examples: “Run demo” or “Generate a sample statement”
* When pressed, the app should:

  1. Generate a long synthetic statement in memory
     Random merchants, random but believable amounts, realistic dates for one or more months
     Include confusing lines such as transfers between accounts, card cash outs, refunds, and duplicate subscriptions
  2. Store that synthetic statement in some client state (context or local storage)
  3. Navigate to the demo flow

The Phase 2 design should give the user an impression of a stressful, messy statement first, then relief once the analysis is done.

### 4.3 Demo dashboard page (`/demo`)

Top summary cards

* Net this month
* Total income
* Total spending
* Total subscriptions

All four values are calculated from the transaction list using helper functions that understand transfers and ownership.

Tabs

Tab id union: `overview`, `recurring`, `fees`, `cashflow`, `review`
Active tab is stored in state and should also sync to local storage so refreshing the page keeps you on the same tab.

Tab behavior

1. Overview tab

   * Shows a grid of spending categories
     Example cards: Rent, Groceries, Dining, Subscriptions, Fees, Utilities, Transport, Other
   * Each card shows a label and total formatted as USD
   * Cards are clickable. The active card gets a brighter border and slightly different background.
   * Under the cards there is a “Transactions for [category]” panel showing:

     * Date (formatted as month name, day, year)
     * Description taken from transaction description
     * Amount with the same currency formatter, red for money leaving and green for incoming where appropriate

   Future improvements for Overview:

   * Add a small pie chart of spending by category below the cards
   * Allow checkboxes or filters to show or hide certain categories
   * Support editing from here by clicking on a transaction row to change its category

2. Recurring tab

   * Shows subscription type spending for this synthetic month
   * Table columns: Name, Category (Subscriptions), Amount, Date
   * Uses proper date formatting with `Intl.DateTimeFormat`
   * Designed to eventually support:

     * Highlighting duplicate or suspicious charges
       Example: streaming service charged twice in one week
     * Visual markers for price increases over previous months in later phases
     * Entry actions such as “Mark as canceled” or “Change category”

3. Fees tab

   * Shows bank and service fees for this month
   * Displays a top row “Total fees this month”
   * Table with Name, Amount, Date
   * Uses the same currency and date formatting
   * In later phases, this can offer hints such as “Switch to a different account type to avoid this maintenance fee”

4. Cash flow tab

   * Shows daily inflow, outflow, and net for the synthetic month
   * The helper function groups transactions by date

     * Inflow equals sum of real income and similar incoming types
     * Outflow equals spending such as expenses, subscriptions, and fees
     * Transfers between your own accounts still appear as movement but should net to zero for that date if both sides are owned
   * Net column uses color to show positive versus negative days

   Future additions:

   * Summary row with total inflow and total outflow for the month
   * Optional filter to include or exclude external transfer types
   * Eventually a visual line chart instead of only a table

5. Review tab

   Sections:

   a. Snapshot cards

   * Income this month
   * Spending this month
   * Net this month
   * Subscriptions count and total
   * Fees total and largest single expense
   * Top spending categories by total amount

   b. Text line clarifying internal transfers
   Example: “Internal transfers between your own accounts are not counted as income or spending in this demo.”

   c. Budget guidance section

   Driven by helper `getBudgetGuidance` in `fakeData.ts`.
   For each chosen category (for example Rent, Transport, Subscriptions, Dining), the helper calculates:

   * Actual amount spent in that category
   * Percentage of income that this represents
   * Recommended percentage from a configurable guideline (for example 30 percent for rent, 15 percent for transport, 5 percent for subscriptions, 10 percent for dining)
   * Recommended dollar amount for that guideline, given the user income
   * Difference amount as a positive number
   * Direction: over compared to the guideline versus under compared to the guideline

   The UI shows a calm explanation line such as:

   * “Rent is about 32 point 5 percent of this month’s income. A common target is about 30 percent. You are over by about 140 dollars compared to this guideline.”
   * “Dining is about 4 point 5 percent of this month’s income. A common target is about 10 percent. You are under by about 316 dollars compared to this guideline.”

   Over amounts show in a soft red tone and under amounts in a soft green tone, but the wording stays neutral.

   Future addition: optional input for ZIP code so you can plug in region specific ranges for rent or transport.

   d. Transfer ownership section

   Title example: “Check transfers between your own accounts.”

   The idea: the engine finds accounts involved in transfers and shows each account so the user can declare which ones belong to them.

   For each detected account:

   * Display name, for example “Navy Federal checking.”
   * Show last four digits of the account number or card, always padded to four digits.
     Example: “Navy Federal checking ending 3124”, “Cash App ending 0884”, “Visa debit ending 9921”.
   * Two buttons: “Yes, my account” and “No, not mine” which control an `OwnershipMap` in state
   * Each button looks like a pill. The selected one appears filled, the other outlined.
   * The label under the section explains that these choices decide whether transfers should be treated as internal and ignored for income and spending math.

   Behavior logic:

   * The transaction model carries `kind` plus optional `sourceKey` and `targetKey` fields that map to these accounts.
   * `OwnershipMap` is a record from account key string to boolean.
   * Helper `isInternalTransfer` looks at transaction kind and these keys, and considers a transfer internal only when both source and target are owned.
   * All total functions receive `OwnershipMap` and use these guards to ignore internal transfers from income and spending.
   * Transfers that involve an account the user marks as “Not mine” are treated as real inflows or outflows.

   Edge behavior:

   * When there are no transfer accounts discovered, this section hides and shows a calm text such as “No transfer accounts detected in this statement.”
   * Buttons are real button elements and should be keyboard accessible.

---

## 5. Data model and helpers in `fakeData.ts`

### 5.1 Transaction type

Representative interface (names can differ, but core idea should match):

```ts
export type TransactionKind =
  | "income"
  | "expense"
  | "subscription"
  | "fee"
  | "transfer_internal_candidate"
  | "transfer_external"
  | "refund";

export type AccountKey =
  | "navy_checking"
  | "cash_app"
  | "visa_debit"
  | string;

export interface Transaction {
  id: string;
  date: string;         // ISO string
  description: string;
  amount: number;       // positive for money coming in, negative for money going out
  category: string;     // human readable spending category
  kind: TransactionKind;
  source: string;       // human label
  target?: string;      // optional human label
  sourceKey?: AccountKey;
  targetKey?: AccountKey;
}
```

Key rule: math must use `amount` and `kind`, with `OwnershipMap` for transfer decisions.

### 5.2 TransferAccount and OwnershipMap

```ts
export interface TransferAccount {
  id: AccountKey;
  label: string;           // example "Navy Federal checking"
  ending: string;          // four digits as string, always length 4
  ownedByDefault: boolean;
}

export type OwnershipMap = Record<AccountKey, boolean>;
```

`getTransferAccounts` returns a list of these with stable `id` values that match `sourceKey` and `targetKey` on transfer transactions.

### 5.3 Helper functions

Core helpers (already present but documented here):

* `isInternalTransfer(tx, ownershipMap)`
  True when transaction is some transfer kind and both `sourceKey` and `targetKey` are owned in the map.

* `isRealIncome(tx, ownershipMap)`
  True when transaction is an income kind and not an internal transfer.

* `isRealSpending(tx, ownershipMap)`
  True when transaction is an expense, subscription, fee or similar and not an internal transfer.
  Refunds can either reduce spending or be counted separately depending on design.

Analytics helpers, all of which should accept an optional `ownershipMap` and rely on the guards:

* `getTotalIncome(transactions, ownershipMap)`
* `getTotalSpending(transactions, ownershipMap)`
* `getNetThisMonth(transactions, ownershipMap)` equal income minus spending from the two helpers
* `getTotalSubscriptions(transactions, ownershipMap)`
* `getTotalFees(transactions, ownershipMap)`
* `getSpendingByCategory(transactions, ownershipMap)`
* `getCashFlowByDate(transactions, ownershipMap)`
* `getSummaryStats(transactions, ownershipMap)`
* `getBudgetGuidance(transactions, ownershipMap)`
* `getTransactionsByCategory(category, transactions, ownershipMap)`

Each helper must treat internal transfers as net zero and ignore them from income and spending.

Budget guidance uses global or configurable guideline percents for each category and returns an array of rich guidance objects with actual, recommended, difference amount, difference direction, and friendly sentences.

---

## 6. Guided demo flow for Phase 2

Phase 2 goal

Turn the current static demo into a step by step experience that feels like a real user uploading a messy statement and watching it get cleaned up.

### 6.1 Entry from Home

Planned behavior:

1. Home shows a clear call to action: “Run demo with a sample statement.”
2. Clicking it triggers a generator function that returns an array of `Transaction` objects, not just a CSV string.
   That generator can be placed in `fakeData.ts` or a new `demoGenerator.ts` module.
3. The generated transactions are stored somewhere shared: context, Zustand store, or even session storage.
4. The app navigates to `/demo`.

Optional extra: a “Show raw statement” button on the first step of the demo which opens a modal with a CSV style table of all raw lines, mimicking a bank export.

### 6.2 Synthetic statement generator

Requirements for the generator:

* Different merchants each run, not the same fixed ones
  Generate semi random names like:
  “Sunrise Grocery Pensacola”, “Blue Wave Internet LLC”, “Cozy Mug Cafe”, “QuickWash Laundry”.
* Realistic date spread for one or more months
  Use a fixed month for now but randomize the exact day and order.
* Mix of transaction kinds:

  * Paychecks or deposits as income
  * Rent or mortgage
  * Utilities and phone
  * Subscriptions with some duplicates
  * Fees
  * Refunds and chargebacks
  * Internal transfers such as “Added from Navy Federal”, “Cash out to Visa debit”, “Transfer to savings”
* Amounts in plausible ranges, not wild nonsense numbers.

The generator should output clean `Transaction` objects.
Later you can also generate a CSV string view for the “statement” screen.

### 6.3 Analysis step

After the user reviews the raw statement, they press a button such as “Analyze this statement.”
This should:

1. Run classification logic if you ever add NLP or pattern rules. For Phase 2, categories can be assigned directly in the generator.
2. Run helper analytics using the transaction list and current ownership map.
3. Navigate or visually transition to the current dashboard layout, which already consumes the helpers.

Important rule:

The engine must not rely on pre known totals. It should always compute them from the transactions. That way, later when a real CSV is fed in, the same functions work.

### 6.4 Restarting the demo

Add a “Restart demo” action somewhere, for example in the Review tab or top right of `/demo`.

Behavior:

* Clears synthetic transactions and generates a fresh set
* Resets ownership choices to defaults
* Keeps the user on `/demo` but resets the active tab to Overview or Review, whichever you choose

Later, you can let the user choose among presets like:

* Single month of checking account only
* Year to date all accounts
* “High subscription mess” preset

---

## 7. Manual controls and editing

Over time you want MoneyMap to feel like an interactive tool, not a read only report. Design for these controls even if they are not implemented yet.

1. Category recategorization

   * From the Overview drilldown table, each row could have:

     * A category badge that opens a small menu to move the transaction to a different category
   * When a user recategorizes a row, the totals, pie chart, and guidance should update live.

2. Manual transaction entry

   * Simple form fields: date, description, amount, category, source, optional target
   * New transaction is appended to the list and treated like any other in the analytics
   * Need clear visual indicator that it is user added, maybe an icon

3. Misclassified transfer fix

   * If the engine mislabels something as an internal transfer but it is actually income or spending, the user should be able to override
   * Either by flipping the ownership toggles or by changing the kind for that row

4. Duplicate membership detection

   * In the Recurring tab, rows that look like suspicious duplicates can be highlighted with a subtle background tint
   * Example: same merchant name and similar amount twice inside a short time window

---

## 8. Multi month and year views

Later phases should support longer time ranges.

Design:

* Global filter section somewhere near the top of `/demo` that allows:

  * Choice of one month like “January 2025”
  * Custom ranges like March through June 2025
  * Full year selection by clicking a “2025” chip which auto selects all months
* When multiple months are selected:

  * Summary cards should reflect totals for the entire range
  * Cash flow can switch between daily and monthly aggregation
  * Review guidance should base percentages on the summed income across the selected months
* Logic for year selection:

  * If the user clicks “2025” it selects all 12 months
  * User can then deselect specific months like “December” if desired

Persistence:

* Selected time range can be stored alongside the active tab in local storage so a refresh keeps the same view.

---

## 9. Error handling and edge cases

You want to anticipate messy realities so the later real version does not blow up.

Consider at least these situations:

* Missing or malformed dates

  * Fall back to skipping those rows or showing them in an “uncategorized” bucket with a warning
* Zero amount rows or test charges

  * Exclude them from totals unless they represent real fees
* Refunds larger than the original charge

  * Treat negative net spending correctly
* Transfers with unknown accounts

  * If only one side is known, treat it as external by default and show a subtle note
* Joint accounts

  * In the future you may need a way to mark “shared” accounts that should partially count toward spending, but that is a stretch goal
* Multiple memberships with similar names

  * For now just highlight them, later you can cluster them
* Inconsistent statement periods

  * For example, data covering 27 days instead of a clean month
  * Make sure percentages and monthly guidance are still understandable

---

## 10. Phased roadmap

Phase 1
Static synthetic demo

* Dark themed responsive layout
* Home, Demo, About routes
* Synthetic transaction list in a TypeScript module
* Summary cards using helper functions
* Overview tab with clickable category cards and drilldown
* Recurring tab with subscription table
* Fees tab with fee table
* Cash flow tab with daily inflow and outflow
* Review tab with snapshot, budget guidance, and transfer ownership section
* Ownership aware math that correctly ignores internal transfers
* Friendly budget guidance sentences
* Short explanatory text that everything is fake and stored locally

Phase 2
Guided demo with random statements

* Home page call to action that generates a new statement
* Synthetic statement generator with random merchants, amounts, and confusing transfers
* First screen where the user sees the messy statement
* Analysis step that builds the same dashboard from the generated data
* Restart demo control
* Better About page: sections for vision, contact example email, placeholder for privacy policy and terms
* Nicer logo than the current “MM” circle

Phase 3
Real data input and advanced tools

* Input for local CSV upload, parsed entirely in the browser
* Mapping from CSV column names to the Transaction type
* Optional PDF parsing if you go that far
* Identification of transfers using pattern matching and possibly a small rules engine
* Saved user preferences for categories, merchants, and ownership defaults
* More advanced charts, including pie charts and trend charts across months
* Optional simple AI assist to explain the user’s situation in plain language, with clear disclaimers

---

## 11. Analytics rule summary

For clarity, these are the rules that should hold everywhere:

* Amount sign
  Positive amount means money into the user
  Negative amount means money leaving the user

* Income
  Sum of all transactions that pass `isRealIncome`
  Internal transfers do not count, even though money moves

* Spending
  Sum of all transactions that pass `isRealSpending`
  Expenses, subscriptions, fees, maybe some external transfer types

* Net
  Net equals total income minus total spending

* Category totals
  Sum of `amount` for transactions that belong to that category and pass `isRealSpending`
  If you want to treat refunds as category specific adjustments, subtract them here

* Cash flow
  For each date:

  * Inflow equals sum of positive real income and other legitimate inflows
  * Outflow equals sum of absolute value of real spending
  * Net equals inflow minus outflow
  * Internal transfers should not change net

* Budget guidance
  The guidance for a category uses:

  * Actual category spending
  * Income total
  * Guideline percentage
  * Recommended dollars equal guideline percent times income
  * Difference equal absolute difference between actual and recommended

---

## 12. Implementation notes and conventions

* Use a single currency formatter and a single date formatter in `demo/page.tsx`
  Example: `Intl.NumberFormat("en US", { style: "currency", currency: "USD" })`
  and `Intl.DateTimeFormat("en US", { month: "short", day: "numeric", year: "numeric" })`

* Keep most business logic in `fakeData.ts` or separate lib modules
  UI components should receive already computed numbers where possible

* Tabs and filters
  Store active tab and selected time range in local storage so refreshes do not reset everything

* Accessibility
  Use semantic elements (button for actions, table markup for tabular data)
  Add aria labels where needed especially on transfer ownership buttons and tab controls

---

## 13. Future stretch ideas

None of these are required now, but they set direction.

* Export results as a PDF or printable report, redacting any account endings
* Simple “what if” sliders for rent, auto payment, or subscription cuts that show how net income would change
* Lightweight rules for “danger signs” like bank fees, payday lenders, or frequent overdrafts
* Education snippets that explain concepts like emergency fund, debt to income, and subscription hygiene
* Support for multiple currencies with a dropdown

---

## Reality check

You are very quickly turning a simple front end demo into something close to a small personal finance product. That is good if you commit, and dangerous if you spread yourself thin.

Main risks:

* Scope creep: every new rule about transfers, ownership, guidance, months, and editing adds another surface where the math can be wrong
* Debug pain: once real CSVs enter the picture, any hidden shortcut in the fake data path will blow up
* Personal time: you still have school, work, and life; this can easily become a black hole for time

Practical advice:

1. Freeze Phase 1 except for critical bugs. Do not bolt on more features to the current demo.
2. For Phase 2, focus narrowly on the guided fake statement and the analysis pipeline. Get that working end to end with completely generated data.
3. Only then think about real uploads.

If you keep this document as the master spec and use it when you start new chats or new Copilot prompts, you will not lose your own ideas and you will avoid re explaining the project every time.
